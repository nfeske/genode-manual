Architecture
############

Contemporary operating systems are immensely complex to accommodate a
large variety of applications on an ever diversifying spectrum of hardware
platforms. Among the functionalities provided by a commodity operating system
are device drivers, protocol stacks such as file systems and network
protocols, the management of hardware resources, as well as the provisioning
of security functions. The latter category is meant for protecting the
confidentiality and integrity of information and the lifelines of critical
functionality. For assessing the effectiveness of such a security function,
two questions must be considered. First, what is the potential attack surface
on the function? The answer to this question yields an assessment about the
likelihood of a breach. Naturally, if there is a large number of potential
attack vectors, the security function is at high risk. The second question is:
What is the reach of a defect? If the compromised function has unlimited
access to all information processed on the system, the privacy of all users
may be affected. If the function is able to permanently install software, the
system may become prone to back doors.

Today's widely deployed operating systems do not isolate security-critical
functions from the rest of the operating system. In contrary, they are
co-located with most other operating-system functionality in a single
high-complexity kernel. Thereby, those functions are exposed to the other
parts of the operating system. The likelihood for of a security breach is as
high as the likelihood for bugs in the overly complex kernel. In other words,
it is certain. Moreover, once an in-kernel function has been compromised, the
defect has an unlimited reach on the system.

The Genode architecture was designed to give more assuring answers to the two
stated questions. Each piece of functionality should be exposed to only those
parts of the system, on which it ultimately depends. But it remains hidden
from all unrelated parts. This minimizes the attack surface on individual
security functions and thereby reduces the likelihood for a security breach.
In the event that one part of the system gets compromised, the reach of the
defect is limited to the particular part and its dependent parts. But
unrelated functionalities remain unaffected. To realize this idea, Genode
composes the system out of many components that interact with each other. Each
component serves a specific role and uses well-defined interfaces to interact
with its peers. For example, a network driver accesses a physical network card
and provides a bidirectional stream of network packets to another component,
which, in turn, may process the packets using a TCP/IP stack and a network
application. Even though the network driver and the TCP/IP stack cooperate
when processing network packets, they are living in separate protection
domains. So a bug in one component cannot observe or corrupt the internal
state of another.

Such a component-based architecture, however, raises a number of questions,
which are addressed throughout this chapter.
Section [Capability-based security] explains how components can cooperate
without inherently trusting each other.
Section [Recursive system structure] answers the questions of who defines the
relationship between components and how components become acquainted with each
other.
An operating system ultimately acts on physical hardware resources such
as memory, CPUs, and peripheral devices.
Section [Core - the root of the process tree] describes how such resources
are made available to components.
Section [Process creation] answers the question of how a new component comes
to life.
The variety of relationships between components and their respective
interfaces call for different communication primitives. Section
[Inter-process communication] introduces inter-component communication
mechanisms in detail.


Capability-based security
=========================

| TODO intro, possibly provide general background information (independent
| from Genode)

This section introduces the nomenclature and the general model of Genode's
capability-based security concept. The Genode OS framework is not tied to one
kernel but supports a variety of kernels as base platforms. On each of those
base platforms, Genode uses different kernel mechanisms to implement the
general model as closely as possible. Note however that not all kernels
satisfy the requirements that are needed to implement the model securely. For
assessing the security of a Genode-based system, the respective
platform-specific implementation must be considered. Section
[Capability-based security in depth] provides details for selected kernels.


Capability spaces, object identities, and RPC objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each component lives inside a protection domain that provides an isolated
execution environment.

[tikz img/protection_domain]

Genode provides an object-oriented way of letting components interact with
each other. Analogously to object-oriented programming languages, which have
the notion of objects and pointers to objects, Genode introduces the notion of
RPC objects and capabilities to RPC objects.

An _RPC object_ provides a remote-procedure call (RPC) interface. Similar to a
regular object, an RPC object can be constructed and accessed from within the
same program. But in contrast to a regular object, it can also be called from
the outside of the component. What a pointer is to a regular object, a
_capability_ is to an RPC object. It is a token that unambiguously refers to
an RPC object. In the following, we represent an RPC object as follows.

[tikz img/rpc_object]

The circle represents the capability associated with the RPC object. Like a
pointer to an object, that can be used to call a function of the pointed-to
object, a capability can be used to call a function of its corresponding RPC
object. However, there are two important differences between a capability and
a pointer. First, in contrast to a pointer that can be created out of thin air
(e.g., by casting an arbitrary number to a pointer), a capability cannot be
created without an RPC object. At the creation time of an RPC object, Genode
creates a so-called _object identity_ that represents the RPC object in the
kernel. The Figure [img/object_identity] illustrates the relationship of an
RPC object and its object identity.

[tikz img/object_identity]
  Relationship between an RPC object and its corresponding object identity.

For each protection domain, the kernel maintains a so-called capability space,
which is a name space local to the protection domain. At the creation time of
an RPC object, the kernel creates a corresponding object identity and lets a
slot in the protection domain's capability space refer to the RPC object's
identity. From the component's point of view, the RPC object A has the name 3.
When interacting with the kernel, the component can use this number to refer
to the RPC object A.


Delegation of authority and ownership
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[tikz img/delegation]
  The transitive delegation of a capability from one protection domain to
  others.

The second difference between a pointer and a capability is that a capability
can be passed to different components without losing its meaning. The transfer
of a capability from one protection domain to another delegates the authority
to use the capability to the receiving protection domain.
This operation is called _delegation_ and can be performed only by the kernel.
Note that originator of the delegation does not diminish its authority by
delegating a capability. It merely shares its authority with the receiving
protection domain.
Figure [img/delegation] shows the
delegation of the RPC object's capability to a second protection domain
and a further delegation of the capability from the second to a third
protection domain.
When the kernel delegates a capability from one to another protection domain,
it inserts a reference to the RPC object's identity a free slot in the
target's capability space. Within protection domain 2, the RPC object can
be referred to by the number 5. Within protection domain 3, the same RPC
object is known as 2.
Note that the capability delegation does not hand over the ownership of the
object identity to the target protection domain. The ownership is always
retained by the protection domain that created the RPC object.

Only the owner of an RPC object is able to destroy it along with the
corresponding object identity. Upon destruction of an object identity, the
kernel removes all references to the vanishing object identity from all
capability spaces. This effectively renders the RPC object inaccessible for
all protection domains. Once the object identity for an RPC object is gone,
the owner can destruct the actual RPC object.


Capability invocation
~~~~~~~~~~~~~~~~~~~~~

Capabilities enable components to call methods of RPC objects
provided by different protection domains. A component that uses
an RPC object plays the role of a _client_ whereas a component that
owns the RPC object acts in the role of a _server_. The interplay between
client and server is very similar to a situation where a program calls
a local function. The caller puts the function arguments to a place where
the callee will be able to pick them up and then passes control to the
callee. When the callee takes over control, it obtains the function
arguments, executes the function, puts the results to a place where the
caller can pick them up, finally hands the control back to the caller.
In contrast to a program-local function call, however, client and server
are different _threads_ in their respective protection domains. The thread
at the server side is called _entrypoint_ denoting the fact that it
becomes active only when a call from a client enters the protection domain.
In order to be able to act as a server, a component has to have at least
one entrypoint.

[tikz img/entrypoint]

The wiggly arrow denotes that the entrypoint is a thread. Besides being a
thread that waits for incoming requests, the entrypoint is responsible for
maintaining the association between RPC objects with their corresponding
capabilities. This association was illustrated by the link between the RPC
object and its capability in the previous figures. In order to become callable
from the outside, an RPC object must be associated with a concrete entrypoint.
This operation results in the creation of the object's identity and the
corresponding capability. During the lifetime of the object identity, the
entrypoint keeps the association between the RPC object and its capability in
a data structure called _object pool_, which allows for looking up the
matching RPC object for a given capability. Figure [img/object_pool] shows a
scenario where two RPC objects are associated with one entrypoint in the
protection domain of a server. The capability for the RPC object A has been
delegated to a client.

[tikz img/object_pool]
  The RPC object A and B are associated with the server's entrypoint.
  A client has a capability for A but not for B.
  For brevity, the kernel-protected object identities are
  not depicted. Instead, the dashed line between the capabilities shows that
  both capabilities refer to the same object identity.

If a protection domain is on possession of a capability, a thread executed
within this protection domain can issue a call to a member function of the RPC
object that is referred to by the capability. Because this is not a normal
function call but the invocation of an object located in a different
protection domain, this operation has to be provided by the kernel. Figure
[img/capability_call] illustrates the interaction of the client, the kernel,
and the server. The kernel operation takes the client-local name of the
invoked capability, the opcode of the called function, and the function
arguments as parameters. When entering the kernel, the client's thread is
blocked until the it receives a response. The operation of the kernel is
represented by the dotted line.
The kernel takes the supplied capability number as an
index into the client's capability space to look up the object identity, to
which the capability refers. Given the object identity, kernel is able to
determine the entrypoint that is associated with the object identity and wakes
up the entrypoint's thread with the information about the incoming request.
Among those information is the server-local name of the capability that was
invoked. Note that the kernel has translated the client-local capability
number into a server-local number. The capability name spaces of client and
server are entirely different. The entrypoint uses this number as a key into
its object pool to find the locally implemented RPC object A that belongs to
the invoked capability. It then performs a method call of the so-called
_dispatch_ function on the RPC object. The dispatch function maps the supplied
function opcode to the matching member function and calls this function
with the request arguments.

[tikz img/capability_call]
  Control flow between client and server when the client calls a method of an
  RPC object.

The member function may produce function results. Once the RPC object's member
function returns, the entrypoint thread passes the function results to the
kernel by performing the kernel's _reply_ operation. At this point, the
server's entrypoint becomes ready for the next request. The kernel, in turn,
passes the function results as return values of the original call operation to
the client and wakes up the client thread.


Capability delegation through capability invocation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Section [Delegation of authority and ownership] explained that capabilities
can be delegated from one protection domain to another via a kernel operation.
But it left open the question how this procedure works. The answer is the use
of capabilities as RPC message payload. Similar to how a caller of a regular
function can pass a pointer as an argument, a client can pass a capability as
an argument to an RPC call. If the kernel encounters a capability as as an
argument of a call operation, it performs the following steps.

[tikz img/capability_argument]
  Procedure of delegating a capability specified as RPC argument from a
  client to a server.

The kernel looks up the object identity in the capability space of the sender.
This lookup may fail if the sender specified a number of an empty slot of
sender's capability space. Only if the lookup succeeds, the kernel is able
obtain the object identity referred to by the argument. Note that under no
circumstances, the client can refer to object identities for which it has no
authority because it can merely specify the object identities reachable
through its capability space. The capability space can be populated only via a
delegation operation. For all object identities reachable through its
capability space, the protection domain had explicitly obtained the
authorization via prior delegation operations.
Given the object identity of the argument, the kernel searches the server's
capability space for a slot that refers to the object identity. If the server
already possesses a capability to the object identity, the kernel translates
the argument to the corresponding local name when passing it as part of the
request to the server. If the server does not yet possess a capability to the
argument, the kernel installs a new entry into the server's capability space.
The new entry refers to the object identity of the argument. At this point,
the authority over the object identity has been delegated from the client to
the server. The kernel passes the just-created local name of the argument
as part of the request to the server.
Even though the above description covered the delegation of a single
capability specified as argument, it is possible to delegate more than one
capability with a single RPC call.

Analogously to how capabilities can be delegated from a client to a server as
arguments of an RPC call, capabilities can be delegated in the other direction
as part of the reply of an RPC call. The procedure in the kernel is the same
in both cases.


Recursive system structure
==========================

The previous section introduced capability delegation as the fundamental
mechanism to pass authority over RPC objects between protection domains. But
in the given examples, the client was already in possession to a capability to
the server's RPC object. This raises the question of how do clients get
acquainted to servers?


Component ownership
~~~~~~~~~~~~~~~~~~~

In a Genode system, each component (except for the initial component) has a
parent, which owns the component. The _ownership_ relation between a parent
and a child is two-fold.

[tikz img/parent_child]

On the one hand, ownership stands for _responsibility_. The parent is
responsible to provide the physical resources (such as a memory budget) to
the child at the creation time but also during the child's entire lifetime.
Creating children is not for free but the parent has to pay for them. Besides
being the provider of resources, the parent defines all aspects of the
child's execution, and serves as the child's primary point of
contact for seeking acquaintances with other components.

[tikz img/parent_capability]
  Initial relationship between a parent and a new created child.

On the other hand, ownership stands for _control_. Because the parent has
created its children out of its own resources, it is in the position to
exercise ultimate power over its children. This includes the decision to
destruct a child at anytime to regain the resources that were assigned
to the child. But it is also in control over the relationships of the child
with other components known to the parent.

Each new component is created as an empty protection domain. It is up to the
parent to populate the protection domain with code and data, and to create a
thread that executes the code within the protection domain. At creation time,
the parent installs a single capability called _parent capability_ into the
new protection domain. The parent capability enables the child to perform RPC
calls to the parent. The child is unaware of anything else that exists in the
Genode system. It does not even know its own identity nor the identity of its
parent. All it can do is issuing calls to its parent using the parent
capability. Figure [img/parent_capability] depicts the situation right after
the creation of a child component. A thread in the parent component created a
new protection domain and a thread residing in the protection domain. It also
installed the parent capability referring to an RPC object provided by the
parent. Section [Process creation] covers the procedure of creating a
component in detail.

The ownership relation between parent and child implies that each component
has to inherently trust its parent. From a child's perspective, its parent
plays the role of the kernel. Whereas the child has to trust its parent,
a parent does not necessarily need to trust its children.


Recursive system structure
~~~~~~~~~~~~~~~~~~~~~~~~~~

The parent-child relationship is not limited to a single level. Child
components are free to use their resources to create further children, thereby
forming a tree of components. Figure [img/recursive_structure] shows an
example scenario. The init component creates sub systems according
to its configuration. In the example, it created two children, namely
a GUI and a launcher. The latter allows the user to interactively create
further subsystems. In the example, launcher was used to start an application.

[tikz img/recursive_structure]
  Example of a tree of components. The red arrow represents the ownership
  relation.

At each position in the tree, the parent-child interface is the same. The
position of a component within the tree is just a matter of composition. For
example, by a mere configuration change of init, the application could be
started directly by the init component and would thereby not be subjected to
the launcher.


Services and sessions
~~~~~~~~~~~~~~~~~~~~~

The primary purpose of the parent interface is the establishment of
of communication channels between components. Any component can inform
its parent about a service that it provides. In order to provide a service,
a component needs to create an RPC object implementing the so-called
_root interface_. The root interface offers functions for creating
and destroying sessions of the service. Figure [img/announce] shows a
scenario where the GUI component announces its service to the init process.
The announce function takes the service name and the capability for the
service's root interface as arguments. Thereby, the root capability is
delegated from the GUI to init.

[tikz img/announce]
  The GUI component announces its service to its parent using the parent
  interface.

It is up to the parent what to do with the announced information. The
parent may ignore the announcement or remember that the child "GUI" provides
a service "GUI". A component can announce any number of services by
subsequent announce calls.

[tikz img/session_request]
  The application requests a GUI session using the parent interface.

The counterpart of the service announcement is the creation of session by
a client by issuing a _session_ request to its parent. Figure
[img/session_request] shows the scenario where the application requests a
"GUI" session. Along with the session call, the client specifies the
name of the service and a number of session arguments. The session arguments
enable the client to inform the server about various properties of the
desired session. In the example, the client informs the server that it
is interested in reading user input and that the client's window should be
labeled with the name "browser". As a result of a session request, the
client expects to obtain a capability to an RPC object that implements
the session interface of the requested service. Such a capability is called
_session capability_.

When the parent receives a session request from a child, it is free to take
a policy decision of how to respond to the request. There are several
options. First, the parent may deny the request and thereby prevent
the child from using a particular service. Second, the parent could decide
to implement the requested service by itself by handing out a session
capability to a locally implemented RPC object to the child. Third, if the
parent has received an announcement of the service from another child, it
may decide to direct the session request to the other child. Finally,
the parent may decide to request a session in the name of its child from
its own parent. The figure illustrates the latter option where the
launcher responds to the session request by the application by
issuing a session request from its parent, the init process. Note that by
requesting a session in the name of its child, the launcher is able to
modify the session arguments according to its policy. In the example,
the launcher imposes the use of a different label to the session. When
init receives the session request from the launcher, it is up to the init
to take a policy decision with the same principle options. In fact, each
component that sits in between the client and the server along the branches
of the ownership tree can impose its policy
to sessions. The final session arguments as received by the server are the
result of the successive application of all policies along the route.

[tikz img/session_root]
  Session creation at the server.


* Client-server relationship
* Application-specific trusted computing base
* Resource accounting
  * Assignment
  * Trading of resources
  * Heap partitioning
* Parent interface
  * Dynamic resource balancing
* Root interface

Core - the root of the process tree
===================================

| TODO

* Physical memory allocation
* Introduction of the services provided by core
  * LOG
  * RAM
  * CAP
  * CPU
  * IO_MEM
  * IO_PORT
  * IRQ
  * PD
  * ROM
  * RM
  * SIGNAL
  * TRACE
* Bootstrapping

Process creation
================

| TODO

Inter-process communication
===========================

| TODO

* Synchronous remote procedure calls (RPC)
* Asynchronous notifications
* Shared memory
* Synchronous bulk
* Asynchronous bulk - packet streams


